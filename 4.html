<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ギア付き3Dキューブシミュレーター</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: #fff;
        }
        #sliders {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            color: #fff;
        }
        button {
            margin: 5px;
            padding: 10px;
            background-color: #333;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #555;
        }
        input[type="range"] {
            width: 100px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="rotateLayerX">X方向層回転</button>
        <button id="rotateLayerY">Y方向層回転</button>
        <button id="rotateLayerZ">Z方向層回転</button>
    </div>
    <div id="sliders">
        <label>X軸回転: <input type="range" id="sliderX" min="-180" max="180" value="0"></label>
        <label>Y軸回転: <input type="range" id="sliderY" min="-180" max="180" value="0"></label>
        <label>Z軸回転: <input type="range" id="sliderZ" min="-180" max="180" value="0"></label>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // シーン、カメラ、レンダラーのセットアップ
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ギアキューブの設定
        const gearSize = 1;
        const gap = 0.2;
        const gearTeethCount = 12; // ギアの歯の数
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xffa500, 0xffffff];
        const gears = [];
        const gearGroup = new THREE.Group();

        // ギアの作成関数
        function createGear(radius, thickness, teeth, x, y, z) {
            const gearGroup = new THREE.Group();
            const base = new THREE.CylinderGeometry(radius, radius, thickness, 32);
            const baseMesh = new THREE.Mesh(base, new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] }));
            baseMesh.rotation.x = Math.PI / 2; // 水平配置
            gearGroup.add(baseMesh);

            // ギアの歯の作成
            for (let i = 0; i < teeth; i++) {
                const tooth = new THREE.BoxGeometry(0.2, 0.1, 0.1);
                const toothMesh = new THREE.Mesh(tooth, new THREE.MeshBasicMaterial({ color: 0xaaaaaa }));
                const angle = (i / teeth) * Math.PI * 2;
                toothMesh.position.set(Math.cos(angle) * (radius + 0.1), Math.sin(angle) * (radius + 0.1), thickness / 2);
                toothMesh.rotation.z = angle;
                gearGroup.add(toothMesh);
            }

            gearGroup.position.set(x * (gearSize + gap), y * (gearSize + gap), z * (gearSize + gap));
            return gearGroup;
        }

        // ギアキューブのパーツを作成して配置
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const gear = createGear(gearSize / 2, 0.2, gearTeethCount, x, y, z);
                    gears.push(gear);
                    gearGroup.add(gear);
                }
            }
        }

        scene.add(gearGroup);
        camera.position.z = 8;

        // 回転関数：層ごとのギアの回転を設定
        function rotateLayer(axis, index, angle) {
            gearGroup.children.forEach(gear => {
                const pos = gear.position[axis];
                if (Math.abs(pos - index * (gearSize + gap)) < 0.1) {
                    const rotationAxis = new THREE.Vector3(
                        axis === 'x' ? 1 : 0,
                        axis === 'y' ? 1 : 0,
                        axis === 'z' ? 1 : 0
                    );
                    gear.rotateOnWorldAxis(rotationAxis, angle);
                }
            });
        }

        // スライダーで視点回転を制御
        const sliderX = document.getElementById('sliderX');
        const sliderY = document.getElementById('sliderY');
        const sliderZ = document.getElementById('sliderZ');

        sliderX.addEventListener('input', () => {
            updateCameraRotation();
        });
        sliderY.addEventListener('input', () => {
            updateCameraRotation();
        });
        sliderZ.addEventListener('input', () => {
            updateCameraRotation();
        });

        function updateCameraRotation() {
            const rotationX = THREE.Math.degToRad(sliderX.value);
            const rotationY = THREE.Math.degToRad(sliderY.value);
            const rotationZ = THREE.Math.degToRad(sliderZ.value);

            camera.rotation.set(rotationX, rotationY, rotationZ);
        }

        // ボタンのイベントリスナー
        document.getElementById('rotateLayerX').addEventListener('click', () => {
            rotateLayer('x', 0, Math.PI / 8);
        });
        document.getElementById('rotateLayerY').addEventListener('click', () => {
            rotateLayer('y', 0, Math.PI / 8);
        });
        document.getElementById('rotateLayerZ').addEventListener('click', () => {
            rotateLayer('z', 0, Math.PI / 8);
        });

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // ウィンドウのリサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
